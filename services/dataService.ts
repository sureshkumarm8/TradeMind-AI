import { Trade, TradeDirection, TradeOutcome, OptionType } from '../types';

export const exportToJSON = (trades: Trade[]) => {
  const dataStr = JSON.stringify(trades, null, 2);
  const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
  const exportFileDefaultName = `trademind_backup_${new Date().toISOString().split('T')[0]}.json`;
  
  const linkElement = document.createElement('a');
  linkElement.setAttribute('href', dataUri);
  linkElement.setAttribute('download', exportFileDefaultName);
  linkElement.click();
}

export const exportToCSV = (trades: Trade[]) => {
  // Define headers map specifically for Nifty Intraday System
  const headers = [
    'ID', 'Date', 'EntryTime', 'ExitTime', 'Instrument', 'OptionType', 'Strike', 
    'NiftySpotEntry', 'NiftySpotExit', 
    'Direction', 'Quantity', 'EntryPrice', 'ExitPrice', 'PnL', 'Outcome', 
    'SpotPoints', 'DurationMins', 
    'Check_PreMarket', 'Check_Wait15m', 'Check_Sensibull', 'Check_ExitLimit', 
    'Setup', 'EntryReason', 'ExitReason', 
    'Confluences', 'Mistakes', 'AI_Analysis'
  ];

  const csvRows = [headers.join(',')];

  trades.forEach(trade => {
    // Helper to safely quote strings that might contain commas
    const q = (str: string | undefined) => `"${(str || '').replace(/"/g, '""')}"`;
    
    const row = [
      trade.id,
      trade.date,
      trade.entryTime || '',
      trade.exitTime || '',
      q(trade.instrument),
      trade.optionType || '',
      trade.strikePrice || '',
      trade.niftyEntryPrice || '',
      trade.niftyExitPrice || '',
      trade.direction,
      trade.quantity,
      trade.entryPrice,
      trade.exitPrice || '',
      trade.pnl || '',
      trade.outcome,
      trade.spotPointsCaptured || '',
      trade.tradeDurationMins || '',
      // System Checks
      trade.systemChecks?.analyzedPreMarket ? 'TRUE' : 'FALSE',
      trade.systemChecks?.waitedForOpen ? 'TRUE' : 'FALSE',
      trade.systemChecks?.checkedSensibullOI ? 'TRUE' : 'FALSE',
      trade.systemChecks?.exitTimeLimit ? 'TRUE' : 'FALSE',
      // Text Data
      q(trade.setupName),
      q(trade.entryReason),
      q(trade.exitReason),
      q((trade.confluences || []).join(' | ')),
      q((trade.mistakes || []).join(' | ')),
      q(trade.aiFeedback) // Full AI Analysis
    ];
    csvRows.push(row.join(','));
  });

  const csvString = csvRows.join('\n');
  const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('download', `trademind_nifty_export_${new Date().toISOString().split('T')[0]}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

export const importData = (file: File): Promise<Trade[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const content = e.target?.result as string;
      try {
        if (file.name.endsWith('.json')) {
           const trades = JSON.parse(content);
           if (Array.isArray(trades)) resolve(trades);
           else reject(new Error("Invalid JSON format. Expected an array of trades."));
        } else if (file.name.endsWith('.csv')) {
           const trades = parseCSV(content);
           resolve(trades);
        } else {
           reject(new Error("Unsupported file type. Please upload .json or .csv"));
        }
      } catch (err) {
        reject(err);
      }
    };
    reader.readAsText(file);
  });
}

// Custom CSV Parser to handle the specific format generated by this app
const parseCSV = (csvText: string): Trade[] => {
   const lines = csvText.trim().split('\n');
   if (lines.length < 2) return [];

   const trades: Trade[] = [];
   
   // Regex to split by comma but ignore commas inside quotes
   const parseRow = (row: string) => {
      const result = [];
      let current = '';
      let inQuote = false;
      for(let i=0; i<row.length; i++) {
         const char = row[i];
         if (char === '"') {
            if (inQuote && row[i+1] === '"') { // Handle escaped quote
               current += '"';
               i++;
            } else {
               inQuote = !inQuote;
            }
         } else if (char === ',' && !inQuote) {
            result.push(current);
            current = '';
         } else {
            current += char;
         }
      }
      result.push(current);
      return result;
   };

   // Skip header row
   for(let i=1; i<lines.length; i++) {
      const values = parseRow(lines[i]);
      if(values.length < 5) continue; // Basic validation
      
      // Map based on export columns order
      // ID, Date, EntryTime, ExitTime, Instrument, OptionType, Strike, NiftySpotEntry, NiftySpotExit...
      const t: any = {
         id: values[0] || crypto.randomUUID(),
         date: values[1],
         entryTime: values[2],
         exitTime: values[3],
         instrument: values[4],
         optionType: values[5] as OptionType,
         strikePrice: values[6] ? Number(values[6]) : undefined,
         niftyEntryPrice: values[7] ? Number(values[7]) : undefined,
         niftyExitPrice: values[8] ? Number(values[8]) : undefined,
         direction: values[9] as TradeDirection,
         quantity: Number(values[10]),
         entryPrice: Number(values[11]),
         exitPrice: values[12] ? Number(values[12]) : undefined,
         pnl: values[13] ? Number(values[13]) : undefined,
         outcome: values[14] as TradeOutcome,
         spotPointsCaptured: values[15] ? Number(values[15]) : 0,
         tradeDurationMins: values[16] ? Number(values[16]) : 0,
         
         systemChecks: {
            analyzedPreMarket: values[17] === 'TRUE',
            waitedForOpen: values[18] === 'TRUE',
            checkedSensibullOI: values[19] === 'TRUE',
            exitTimeLimit: values[20] === 'TRUE'
         },
         
         setupName: values[21],
         entryReason: values[22],
         exitReason: values[23],
         confluences: values[24] ? values[24].split(' | ') : [],
         mistakes: values[25] ? values[25].split(' | ') : [],
         aiFeedback: values[26]
      };
      
      // Basic Data Cleanup
      if (!t.timeframe) t.timeframe = '5m'; 
      
      trades.push(t);
   }
   return trades;
}